# Story 5.2: Stav a logika herních režimů

## Epic
Epic 5: Přepínač herních režimů

## Uživatelský příběh

Jako vývojář hry
Chci mít centralizovaný stav, který určuje aktivní herní režim a řídí průběh tahů
Abych zajistil, že UI i herní logika reagují konzistentně na volbu hráče

## Popis

Rozšířit stavovou logiku aplikace tak, aby podporovala dva herní režimy: PVP a režim proti počítači. Zahrnuje uložení zvoleného režimu, reakci na přepnutí během hry a správné řízení tahu počítače v případě AI režimu. Je potřeba pokrýt stávající správu tahu, historii tahů a resetování hry.

## Úkoly

### Úkol 1: Úložiště stavu režimu (např. `src/state/gameState.ts`)
- [ ] Přidat položku stavu reprezentující aktivní režim (enum/string)
- [ ] Zajistit výchozí hodnotu PVP
- [ ] Exponovat setter/akci pro změnu režimu

### Úkol 2: Reakce na přepnutí režimu
- [ ] Aktualizovat logiku střídání hráčů, aby respektovala zvolený režim
- [ ] Při přepnutí do AI režimu ověřit, kdo je na tahu, a případně spustit AI tah
- [ ] Při návratu do PVP zastavit plánované AI tahy

### Úkol 3: Integrace s UI a persistencí
- [ ] Napojit UI přepínač na stav (prop/context/store)
- [ ] Zvážit uložení režimu v URL nebo localStorage, pokud to odpovídá stávajícímu chování
- [ ] Zajistit, že reset hry respektuje aktuální režim

## Akceptační kritéria

1. Stav hry obsahuje informaci o aktuálním režimu a lze ji měnit během sezení
2. Při přepnutí do AI režimu se AI přihlásí o tah v souladu s aktuálním pořadím
3. Při přepnutí zpět na PVP se AI tahy nevyvolávají
4. Reset hry zachová zvolený režim (pokud není rozhodnuto jinak v požadavcích)
5. Existující logika PVP režimu funguje stejně jako před úpravou

## Testovací plán

1. Jednotkové testy pro reducer/store ověřují výchozí hodnotu a změnu režimu
2. Integrační test simuluje přepnutí režimu během hry a kontroluje pořadí tahů
3. Test pro reset hry kontroluje zachování režimu
4. Manualně přepnout režimy při rozehrané hře a sledovat konzistenci UI
5. Ověřit, že nedochází k pádu aplikace při rychlém přepínání

## Poznámky

- Držet se stávající architektury stavu (React state, Zustand, Redux apod.)
- Myslet na asynchronní povahu AI tahu (timeout/promisy)
- Ujistit se, že změny nenaruší obstarávání historie tahů nebo undo, pokud existují
